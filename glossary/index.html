<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8"> 
        <meta charset="utf-8">
        <meta name="generator" content="Bootply" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<title>StructureMap - Glossary</title>
		<link href="/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
		<link href="/content/prism.css" rel="stylesheet" type="text/css" />
		<link href="/content/theme.css" rel="stylesheet" type="text/css" />
		
        

        <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
        <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">


        <!-- CSS code from Bootply.com editor -->
        <link href="/content/affix.css" rel="stylesheet" type="text/css" />
    </head>
    
    <!-- HTML code from Bootply.com editor -->
    
    <body  >

<a href="https://github.com/structuremap/structuremap"><img style="z-index: 5000; position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
        
        <nav class="navbar navbar-default navbar-fixed-top" role="banner">
		  <div class="container">
		    <div class="navbar-header">
		      <a href="/" class="navbar-brand">StructureMap</a>
		    </div>
		    <nav class="collapse navbar-collapse" role="navigation">
		      <ul class="nav navbar-nav">
            <li>
              <a href="/quickstart">A Gentle Quickstart</a>
            </li>
		        <li>
		          <a href="/documentation">Documentation</a>
		        </li>
            <li>
              <a href="https://groups.google.com/forum/#!forum/structuremap-users">Google Group</a>
            </li>
		        <li>
<a href="https://gitter.im/structuremap/structuremap?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/structuremap/structuremap" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
		        </li>
		      </ul>

		      <ul class="nav navbar-nav navbar-right">
		      	<li><a href="/quickstart" title="A Gentle Quickstart">Previous</a></li>
		      	<li><a href="/get-structuremap" title="Get StructureMap">Next</a></li>
		      </ul>
		    </nav>

		  </div>
		</nav>

		  <div class="container">
		  	<nav class="navbar-inverse">
		  		<ol class="breadcrumb"><li><a href="/">StructureMap</a></li><li class="active">Glossary</li></ol>
		  	</nav>
		  </div>

		<!--main-->
		<div class="container">
			<div class="row">
		      <!--left-->
		      
		      <div class="col-md-3" id="leftCol">
		      	<h3>StructureMap 3.1.6</h3>
		      	<br />

				<ul class="nav nav-stacked affix" id="sidebar">

		        </ul>

		        	<h3 class="no-margin">Next</h3><p><a href="/get-structuremap">Get StructureMap</a></p>
		        	<h3 class="no-margin">Previous</h3><a href="/quickstart">A Gentle Quickstart</a></p>

		        </ul>
		      </div><!--/left-->
		      
		      <!--right-->
		      <div class="col-md-9">
			      	<h1>Glossary</h1>
			      
			      	<hr />

			      	<div id="main-pane">
			      		<!--Title: Glossary-->
<p>There are some terms that reoccur throughout the documentation and show up in the StructureMap API. Understanding these terms and how they relate to StructureMap isn't a prerequisite to using StructureMap, but it helps.</p>
<h2>Container</h2>
<p>Tools like StructureMap are generally known as <em>Inversion of Control (IoC) Containers</em> or <em>Dependency Injection (DI) Containers</em>. In the Java world they are also known as <em>Lightweight Containers</em> to differentiate them from the older <em>EJB Containers</em>.</p>
<p>A container is a tool that can help you composing object graphs and managing their scope (lifecycle). Altough you can do Inversion of Control and Dependecy Injection manually, using tools like StructureMap makes you far more productive and succesfull in doing so.</p>
<p>Obviously there is more to a container then resolving services and managing their scope, but in the core that's just what it is. Before you can do so you need to tell StructureMap, the container, how it must compose those objects graphs and what their lifecycle is. This is called registration and can be done in various mixed ways. The strongly recommend way would be using the <a href="/registration/registry-dsl">Registry DSL</a>. In your registration your basicaly mapping abstractions to concrete types and define their lifecycle.</p>
<p>A simple example of a container using the <a href="/registration/registry-dsl">Registry DSL</a>:</p>
<pre><code class="language-csharp">
    public class FooBarRegistry : Registry
    {
        public FooBarRegistry()
        {
            For&lt;IFoo&gt;().Use&lt;Foo&gt;();
            For&lt;IBar&gt;().Use&lt;Bar&gt;();
        }
    }

</code></pre>
<pre><code class="language-csharp">
            var container = new Container(c =&gt; { c.AddRegistry&lt;FooBarRegistry&gt;(); });
</code></pre>
<p>Because we didn't specify the lifecycle for both registrations, the default <code>Transient</code> lifecycle will be used.  This will instruct the container to create a new instance for every request for a plugin type <code>IFoo</code> or <code>IBar</code>.</p>
<p>More advanced features that the container can do are things like: Interception, Auto-Wiring, Forwarding Types.</p>
<h2>Nested Container</h2>
<p>A nested container is used to mark the scope of short lived transactions or web requests and track and clean up objects implementing the <code>IDisposable</code> interface for that operation.</p>
<p>You can ask a existing container to create a nested container for you like in the following example:</p>
<pre><code class="language-csharp">
            using (var nested = someExistingContainer.GetNestedContainer())
            {
                // pull other objects from the nested container and do work with those services
                var service = nested.GetInstance&lt;IService&gt;();
                service.DoSomething();
            }
</code></pre>
<p>For more detailed information about nested containers and their special properties you can read the &lt;linkto:the-container/nested-containers]&gt; topic.</p>
<h2>PluginType and PluggedType</h2>
<p>The term plugin type is used throughout the code and documentation to mean the type that you want to register or resolve. More generally this type is known as the service type. This type can be a concrete class or in most cases, it will be a form of abstraction like an abstract class or interface.</p>
<p>The term plugged type means the actual concrete type that you get when you request the plugin type. This type must obviously implement the plugin type contract.</p>
<p>In your registration you could have something like this:</p>
<pre><code class="language-csharp">
    public class FooRegistry : Registry
    {
        public FooRegistry()
        {
            For&lt;IFoo&gt;().Use&lt;Foo&gt;();
        }
    }

</code></pre>
<pre><code class="language-csharp">
//For&lt;PLUGINTYPE&gt;().Use&lt;PLUGGEDTYPE&gt;()

            var container = new Container(c =&gt; { c.AddRegistry&lt;FooRegistry&gt;(); });

            container.GetInstance&lt;IFoo&gt;();

//container.GetInstance&lt;PLUGINTYPE&gt;()
</code></pre>
<p>If you request an object of <code>IFoo</code>, you'll get an instance of the <code>Foo</code> class. In this case, <code>IFoo</code> is the plugin type (what you're asking for) and <code>Foo</code> is the plugged type (the concrete class you'll get that fulfills, implements the plugin type contract).</p>
<h2>PluginFamily</h2>
<p>This term you will not see so often because it's mostly used by StructureMap itself. A <code>PluginFamily</code> represents a <a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">CLR</a> type (the plugin type) that StructureMap can build, and all of the possible plugged types that implement the <a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">CLR</a> type.</p>
<p>In the following code StructureMap internally creates one <code>PluginFamily</code> of the plugin type <code>IFoo</code> with two instances <code>Foo</code> and <code>SomeOtherFoo</code>, where <code>Foo</code> is the default instance because it's registered through <code>For&lt;PLUGIN_TYPE&gt;().Use&lt;PLUGGED_TYPE&gt;()</code>.</p>
<pre><code class="language-csharp">
            var container = new Container(c =&gt;
            {
                c.For&lt;IFoo&gt;().Use&lt;Foo&gt;();
                c.For&lt;IFoo&gt;().Add&lt;SomeOtherFoo&gt;();
            });
</code></pre> 
<p>Before StructureMap 3.0 you have probably seen the term used in an exception message when you request a plugin type that doesn't have a default instance defined.</p>
<pre><code>StructureMap Exception Code:  202
No Default Instance defined for PluginFamily [plugin type]
</code></pre>
<p>This specific exception message is gone in 3.0 because the exception messages were modernized in version 3.0 and.</p>
<h2>Plugin Graph</h2>
<p>A <code>PluginGraph</code> is the configuration model of the runtime configuration of a StructureMap container. The <code>PluginGraph</code> model can be manipulated directly in StructureMap 3.0 for
any kind of special convention that doesn't fit into the existing conventional support.</p>
<h2>Instance</h2>
<p>In StructureMap terms, an &quot;Instance&quot; is a configured and named strategy to build or locate a named object instance for a requested Plugin Type.  An &quot;Instance&quot; does not automatically equate to a concrete type.  For example, let's say that we're building a system to automate a warehouse.  Our system might consume an interface called IShippingService that acts as a Gateway to various ways of shipping boxes out of our warehouse.</p>
<pre><code class="language-csharp">
    public interface IShippingService
    {
        void ShipIt();
    }

</code></pre>
<p>Our warehouse system might have to interact with three types of shipping:  domestic, international, and intra-company or internal shipments.  The internal shipping service runs in process with the warehouse application, but domestic and international shipping is done by invoking external web services.  The registration of the IShippingService Instances might look like this:</p>
<pre><code class="language-csharp">
    public class ShippingRegistry : Registry
    {
        public ShippingRegistry()
        {
            For&lt;IShippingService&gt;().AddInstances(x =&gt;
            {
                x.Type&lt;ShippingWebService&gt;()
                    .Ctor&lt;string&gt;(&quot;url&quot;).Is(&quot;a url&quot;)
                    .Named(&quot;Domestic&quot;);

                x.Type&lt;ShippingWebService&gt;()
                    .Ctor&lt;string&gt;(&quot;url&quot;).Is(&quot;a different url&quot;)
                    .Named(&quot;International&quot;);

                x.Type&lt;InternalShippingService&gt;().Named(&quot;Internal&quot;);
            });
        }
    }

</code></pre>
<p>In the registration code above, there are three &quot;Instance's.&quot;  You can access the various IShippingService Instance's by name:</p>
<pre><code class="language-csharp">
            var container = new Container(new ShippingRegistry());

            // Accessing the IShippingService Instance&#39;s by name
            var internationalService = container.GetInstance&lt;IShippingService&gt;(&quot;International&quot;);
            var domesticService = container.GetInstance&lt;IShippingService&gt;(&quot;Domestic&quot;);
            var internalService = container.GetInstance&lt;IShippingService&gt;(&quot;Internal&quot;);

</code></pre>
<p>Asking for the &quot;International&quot; or the &quot;Domestic&quot; instance of IShippingService will both return an object of type ShippingWebService, but the two objects will be differently configured with unique Url's.</p>
<p>There is an actual class in StructureMap that represents an &quot;<a href="https://github.com/structuremap/structuremap/blob/master/src/StructureMap/Pipeline/Instance.cs">Instance</a>.&quot;</p>
<p>When you call <code>Container.GetInstance&lt;T&gt;(&quot;the instance that I want&quot;)</code> or <code>Container.GetInstance&lt;T&gt;()</code>, the internal <code>Container</code> object is locating the correct Instance object and then using the Instance's internal <em>build plan</em> to resolve or construct the actual object.</p>
<p>A StructureMap &quot;Instance&quot; is a close analogue for what many other IoC tools call a &quot;Component.&quot;</p>
<h2>Lifecycle (or Scope)</h2>
<p>The power of an IoC container isn't just in building object graphs for you, it's also about <em>scoping</em> an object graph to what StructureMap calls a <em>lifecycle</em>.  Think of it this way,
when you ask StructureMap for a service or much more commonly when StructureMap is filling a dependency behind the scenes, do you want:</p>
<ul>
<li>A brand new, unique object each time?</li>
<li>The exact same object as the rest of the graph is using?</li>
<li>The exact same object every single time throughout the application?</li>
</ul>
<h2>Registry</h2>
<p>A <code>Registry</code> or a sub class of <code>Registry</code> is a class that let's you create reusable configuration for StructureMap containers.</p>
<h2>Profile</h2>
<p>StructureMap 3.0 features a complete rewrite of the ancient <em>Profile</em> functionality where you can create your base Container configuration with additional <em>Profile</em>
configuration that overrides one or more of the parent Container defaults.  The <em>Profile</em> functionality was originally meant to handle difference between
development, testing, and production environments but has been more commonly used for multi-tenancy situations.  Think of a <em>Profile</em> as an application or tenant mode.</p>
<h2>Auto wiring</h2>
<p>You'd never get anything done if you had to tell StructureMap how to build each and every constructor or setter dependency on every concrete class.  Fortunately, StructureMap like
most IoC container tools, supports the concept of <em>auto-wiring</em> -- meaning that StructureMap can happily infer dependency requirements from constructor functions and setter
rules and fill those dependencies with the default configuration for the declared dependency type.</p>
<p>Let's just see it in action:</p>
<pre><code class="language-csharp">
    public interface Xman
    {
    }

    public class Cyclops : Xman
    {
    }

    public interface Avenger
    {
    }

    public class IronMan : Avenger
    {
    }

    public class CrossoverEvent
    {
        public Xman Xman { get; set; }
        public Avenger Avenger { get; set; }

        public CrossoverEvent(Xman xman, Avenger avenger)
        {
            Xman = xman;
            Avenger = avenger;
        }
    }

    public class UsingCrossover
    {
        [Test]
        public void showing_auto_wiring()
        {
            var container = new Container(x =&gt;
            {
                x.For&lt;Xman&gt;().Use&lt;Cyclops&gt;();
                x.For&lt;Avenger&gt;().Use&lt;IronMan&gt;();
            });

            // Notice that at no point did we define how to 
            // build CrossoverEvent.  
            var @event = container.GetInstance&lt;CrossoverEvent&gt;();
            @event.Avenger.ShouldBeOfType&lt;IronMan&gt;();
            @event.Xman.ShouldBeOfType&lt;Cyclops&gt;();
        }
    }

</code></pre>


			      	</div>

			      	<hr />

			      	<nav>
				        <span>
				        	<strong>Previous: </strong><a href="/quickstart">A Gentle Quickstart</a>

				        </span>
				        <span class="pull-right">

				        	<strong>Next: </strong><a href="/get-structuremap">Get StructureMap</a>

				        </span>
			      	</nav>

		      </div><!--/right-->
		  	</div><!--/row-->
		</div><!--/container-->


    </body>


    <foot>
        <script type='text/javascript' src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
        <script type='text/javascript' src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

        <script type="text/javascript" src="/content/embed.js"></script>
        <script type="text/javascript" src="/content/prism.js"></script>
        <script type="text/javascript" src="/content/sidebar.js"></script>
        <script type="text/javascript" src="/content/affix.js"></script>
    </foot>
</html>

